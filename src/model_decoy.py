# -*- coding: utf-8 -*-
"""
Created on Mon Jul  3 14:10:40 2023

@author: vil034

Model for the two decoy state QSTT
"""


import numpy as np
import detector

class ModelDecoy:
    def __init__(self, mu1, mu2):
        # Defaul model parameters corresponsing to a realistic setup
        self.distance = 100000 # 10 km separation Alice and Bob
        
        # Source rate
        self.pulse_repetition_rate = 10
        
        # Loss
        self.detector_loss = 4
        self.channel_loss = 25
        
        # Jitter
        self.detector_jitter = 350e-6
        self.atmosphere_turbulence_jitter = 20e-6
        self.time_tag_jitter = 42e-6
        
        self.detector_dead_time = 30e-3
        
        self.background_counts_radiation_rate_sec =  10e3 # In seconds
        self.dark_count_rate_sec = 200 # In seconds
        
        self.qber = .01 
        
        self.p_signal = 0.5
        
        # Pulse mean photon numbers
        # mu1 = signal 
        # mu2 = decoy
        self.mu1 = mu1
        self.mu2 = mu2
        
        
    def set_loss(self, loss, detector_loss = 0):
        self.detector_loss = detector_loss
        self.channel_loss = loss
        
        
    def set_background_rate(self, background_counts_rate, dark_count_rate=0):
        self.background_counts_radiation_rate_sec =  background_counts_rate # In seconds
        self.dark_count_rate_sec = dark_count_rate
        
        
    def set_qber(self, qber):
        self.qber = qber
        
    def set_jitter(self, jitter):
        # Jitter
        self.detector_jitter = 0
        self.atmosphere_turbulence_jitter = 0
        self.time_tag_jitter = jitter
        

    def set_pulse_rate(self, rate):
        self.pulse_repetition_rate = rate

    def generate_time_data(self, time_shift, start_time, total_protocol_time_sec, verbose=False):
        ############ System parameters
        # All time is set in unit of microsecond 1e-6
        
        # detector_time_res = 50e-6  # time resolution of the detector - 50ps
        
        # total_protocol_time_sec = .001
        total_protocol_time = total_protocol_time_sec * 1e6 # protocol duration in microsecond
     
        
        # pair_generation_time = 1/entangled_pair_rate
        
        c = 299792458 # speed light m/s
       
         
        N_background_counts = (self.background_counts_radiation_rate_sec + 4*self.dark_count_rate_sec)*total_protocol_time_sec
        N_background_counts = int(N_background_counts)
        
        
  
        background_count_times = np.random.rand(N_background_counts)*total_protocol_time + start_time
        
        
        ######################## Creating the time samples
        
        
        # Alice and Bob parameters     
        bob_loss_dB = self.detector_loss + self.channel_loss
        bob_transmissivity = 10**(-bob_loss_dB/10)
        
        alice_jitter =  self.time_tag_jitter
        bob_jitter = np.sqrt(self.detector_jitter**2 + self.atmosphere_turbulence_jitter**2 + self.time_tag_jitter**2)
        
        # Signal are generated by Alice who keeps a timestamp for each pulse
        alice_times = np.arange(start_time, start_time + total_protocol_time, 1/self.pulse_repetition_rate)
        N_pulses = len(alice_times)

        # Create quantum information of the created states
        alice_quantum = np.random.choice([1, -1], N_pulses)

        # If a pulse is decoy its entry in the signal_quantum = 0
        mask = np.random.rand(N_pulses)  < self.p_signal       
        alice_quantum[mask] = 0
        
        
        # Bob entangled pair times & quantum info         
        bob_click_probability = np.ones(N_pulses)
        bob_click_probability[alice_quantum == 0] = 1 - np.exp(-bob_transmissivity*self.mu2)
        bob_click_probability[alice_quantum != 0] = 1 - np.exp(-bob_transmissivity*self.mu1)
            
        photons_loss_roll_bob = np.random.rand(N_pulses)
        mask = photons_loss_roll_bob < bob_click_probability
        bob_pair_times = alice_times[mask]
        bob_quantum = alice_quantum[mask]


        # Add qber error to Bobs quantum info
        errors = np.ones(len(bob_quantum))
        error_roll = np.random.rand(len(bob_quantum))
        errors[error_roll < self.qber] *= -1
        bob_quantum *= errors.astype(int)
    
        # Count the coincidences
        # coincidences = 0
        # for ti in bob_pair_times:
        #     if ti in alice_times:
        #         coincidences += 1
        
        # Add time jitter to Bob source times
        jitter_roll_alice = np.random.normal(0, alice_jitter, len(alice_times))
        alice_times = alice_times + jitter_roll_alice
        
        jitter_roll_bob = np.random.normal(time_shift, bob_jitter, len(bob_pair_times))
        bob_pair_times = bob_pair_times + jitter_roll_bob
        
    
        
        bob_times = np.concatenate((bob_pair_times, background_count_times))
        sort_ind = np.argsort(bob_times)
        bob_times = bob_times[sort_ind]
        
        # bob_quantum_thermal = np.zeros(N_background_counts)
        bob_quantum_thermal = np.random.choice([1, -1], N_background_counts) 
        bob_quantum = np.concatenate((bob_quantum, bob_quantum_thermal))
        bob_quantum = bob_quantum[sort_ind]
       
        # Remove counts that fall within the detector dead time - see detector.py
        bob_times, bob_quantum = detector.remove_dead_times_w_quantum(bob_times, bob_quantum, self.detector_dead_time)
        alice_times, alice_quantum = detector.remove_dead_times_w_quantum(alice_times, alice_quantum, self.detector_dead_time)
        
        # Approximated - real number is less because of detector dead time
        N_coincidences = int(np.floor(N_pulses*np.average(bob_click_probability))) 
        
        if verbose:
            print('Protocol time: ', total_protocol_time)
            print('Number of pulses: ', N_pulses)
            
            print('Alice jitter: ', alice_jitter)
            print('Bob jitter: ', bob_jitter)
            
            total_jitter = np.sqrt(alice_jitter**2 +bob_jitter**2)
            print('Total jitter: ', total_jitter)
            
            print('Alice pairs detected: ', len(alice_times))
            print('Bob pairs detected: ', len(bob_pair_times))
            print('Bob background counts: ', N_background_counts)
            print('Bob total counts: ', len(bob_times))
            
            
            total_background_rate = (self.background_counts_radiation_rate_sec + self.dark_count_rate_sec)*1e-6
            print('Num background noise: ', N_pulses*total_background_rate*4*total_jitter)
            # print('S: ', N_created_pairs*bob_transmissivity* alice_transmissivity/(total_background_rate*4*total_jitter))             
            # print('Total coincidences: ', coincidences) 
            print('Total coincidences predicted: ', N_coincidences) 
    
            
            
            print('--------------------------------')
    
            
            
        return alice_times, bob_times, alice_quantum, bob_quantum
    
    
    